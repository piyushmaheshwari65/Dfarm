{"ast":null,"code":"var _regeneratorRuntime = require(\"/home/piyush/Documents/GitHub/Dfarm/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/piyush/Documents/GitHub/Dfarm/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar BufferList = require('bl/BufferList');\n\nvar Reader = require('it-reader');\n\nmodule.exports = function LteReader(source) {\n  var reader = Reader(source);\n  var overflow;\n  var lteReader = {\n    [Symbol.asyncIterator]: function () {\n      return lteReader;\n    },\n    next: function next(bytes) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var value, _yield$reader$next, nextValue, done;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!overflow) {\n                  _context.next = 22;\n                  break;\n                }\n\n                if (!(bytes == null || overflow.length === bytes)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                value = overflow;\n                overflow = null;\n                _context.next = 21;\n                break;\n\n              case 6:\n                if (!(overflow.length > bytes)) {\n                  _context.next = 11;\n                  break;\n                }\n\n                value = overflow.shallowSlice(0, bytes);\n                overflow = overflow.shallowSlice(bytes);\n                _context.next = 21;\n                break;\n\n              case 11:\n                if (!(overflow.length < bytes)) {\n                  _context.next = 21;\n                  break;\n                }\n\n                _context.next = 14;\n                return reader.next(bytes - overflow.length);\n\n              case 14:\n                _yield$reader$next = _context.sent;\n                nextValue = _yield$reader$next.value;\n                done = _yield$reader$next.done;\n\n                if (!done) {\n                  _context.next = 19;\n                  break;\n                }\n\n                throw Object.assign(new Error(\"stream ended before \".concat(bytes - overflow.length, \" bytes became available\")), {\n                  code: 'ERR_UNDER_READ'\n                });\n\n              case 19:\n                value = new BufferList([overflow, nextValue]);\n                overflow = null;\n\n              case 21:\n                return _context.abrupt(\"return\", {\n                  value: value\n                });\n\n              case 22:\n                return _context.abrupt(\"return\", reader.next(bytes));\n\n              case 23:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))();\n    },\n    nextLte: function nextLte(bytes) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _yield$lteReader$next, done, value;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return lteReader.next();\n\n              case 2:\n                _yield$lteReader$next = _context2.sent;\n                done = _yield$lteReader$next.done;\n                value = _yield$lteReader$next.value;\n\n                if (!done) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", {\n                  done: done\n                });\n\n              case 7:\n                if (!(value.length <= bytes)) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", {\n                  value: value\n                });\n\n              case 9:\n                value = BufferList.isBufferList(value) ? value : new BufferList(value);\n\n                if (overflow) {\n                  overflow.append(value.shallowSlice(bytes));\n                } else {\n                  overflow = value.shallowSlice(bytes);\n                }\n\n                return _context2.abrupt(\"return\", {\n                  value: value.shallowSlice(0, bytes)\n                });\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }))();\n    },\n    return: function _return() {\n      return reader.return();\n    }\n  };\n  return lteReader;\n};","map":{"version":3,"sources":["/home/piyush/Documents/GitHub/Dfarm/node_modules/it-tar/lte-reader.js"],"names":["BufferList","require","Reader","module","exports","LteReader","source","reader","overflow","lteReader","Symbol","asyncIterator","next","bytes","length","value","shallowSlice","nextValue","done","Object","assign","Error","code","nextLte","isBufferList","append","return"],"mappings":"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","sourcesContent":["const BufferList = require('bl/BufferList')\nconst Reader = require('it-reader')\n\nmodule.exports = function LteReader (source) {\n  const reader = Reader(source)\n  let overflow\n  const lteReader = {\n    [Symbol.asyncIterator]: () => lteReader,\n    async next (bytes) {\n      if (overflow) {\n        let value\n        if (bytes == null || overflow.length === bytes) {\n          value = overflow\n          overflow = null\n        } else if (overflow.length > bytes) {\n          value = overflow.shallowSlice(0, bytes)\n          overflow = overflow.shallowSlice(bytes)\n        } else if (overflow.length < bytes) {\n          const { value: nextValue, done } = await reader.next(bytes - overflow.length)\n          if (done) {\n            throw Object.assign(\n              new Error(`stream ended before ${bytes - overflow.length} bytes became available`),\n              { code: 'ERR_UNDER_READ' }\n            )\n          }\n          value = new BufferList([overflow, nextValue])\n          overflow = null\n        }\n        return { value }\n      }\n      return reader.next(bytes)\n    },\n    async nextLte (bytes) {\n      let { done, value } = await lteReader.next()\n      if (done) return { done }\n      if (value.length <= bytes) return { value }\n      value = BufferList.isBufferList(value) ? value : new BufferList(value)\n      if (overflow) {\n        overflow.append(value.shallowSlice(bytes))\n      } else {\n        overflow = value.shallowSlice(bytes)\n      }\n      return { value: value.shallowSlice(0, bytes) }\n    },\n    return () {\n      return reader.return()\n    }\n  }\n  return lteReader\n}\n"]},"metadata":{},"sourceType":"script"}