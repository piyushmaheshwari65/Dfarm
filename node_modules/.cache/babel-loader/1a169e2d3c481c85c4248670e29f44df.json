{"ast":null,"code":"'use strict';\n\nvar protons = require('protons');\n\nvar proto = protons(require('./dag.proto.js'));\n\nvar DAGLink = require('./dag-link/dagLink');\n\nexports = module.exports;\n\nvar toProtoBuf = function toProtoBuf(node) {\n  var pbn = {};\n\n  if (node.Data && node.Data.byteLength > 0) {\n    pbn.Data = node.Data;\n  } else {\n    // NOTE: this has to be null in order to match go-ipfs serialization\n    // `null !== new Uint8Array(0)`\n    pbn.Data = null;\n  }\n\n  if (node.Links && node.Links.length > 0) {\n    pbn.Links = node.Links.map(function (link) {\n      return {\n        Hash: link.Hash.bytes,\n        Name: link.Name,\n        Tsize: link.Tsize\n      };\n    });\n  } else {\n    pbn.Links = null;\n  }\n\n  return pbn;\n};\n/**\n * Serialize internal representation into a binary PB block.\n *\n * @param {Object} node - Internal representation of a PB block\n * @returns {Uint8Array} - The encoded binary representation\n */\n\n\nvar serializeDAGNode = function serializeDAGNode(node) {\n  var data = node.Data;\n  var links = node.Links || [];\n  var serialized = proto.PBNode.encode(toProtoBuf({\n    Data: data,\n    Links: links\n  }));\n  return serialized;\n}; // Serialize an object where the `Links` might not be a `DAGLink` instance yet\n\n\nvar serializeDAGNodeLike = function serializeDAGNodeLike(data) {\n  var links = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var node = {\n    Data: data\n  };\n  node.Links = links.map(function (link) {\n    return DAGLink.isDAGLink(link) ? link : DAGLink.util.createDagLinkFromB58EncodedHash(link);\n  });\n  return serializeDAGNode(node);\n};\n\nexports.serializeDAGNode = serializeDAGNode;\nexports.serializeDAGNodeLike = serializeDAGNodeLike;","map":{"version":3,"sources":["/home/piyush/Documents/GitHub/Dfarm/node_modules/ipld-dag-pb/src/serialize.js"],"names":["protons","require","proto","DAGLink","exports","module","toProtoBuf","node","pbn","Data","byteLength","Links","length","map","link","Hash","bytes","Name","Tsize","serializeDAGNode","data","links","serialized","PBNode","encode","serializeDAGNodeLike","isDAGLink","util","createDagLinkFromB58EncodedHash"],"mappings":"AAAA;;AAEA,IAAMA,OAAO,GAAGC,OAAO,CAAC,SAAD,CAAvB;;AACA,IAAMC,KAAK,GAAGF,OAAO,CAACC,OAAO,CAAC,gBAAD,CAAR,CAArB;;AACA,IAAME,OAAO,GAAGF,OAAO,CAAC,oBAAD,CAAvB;;AAEAG,OAAO,GAAGC,MAAM,CAACD,OAAjB;;AAEA,IAAME,UAAU,GAAG,SAAbA,UAAa,CAACC,IAAD,EAAU;AAC3B,MAAMC,GAAG,GAAG,EAAZ;;AAEA,MAAID,IAAI,CAACE,IAAL,IAAaF,IAAI,CAACE,IAAL,CAAUC,UAAV,GAAuB,CAAxC,EAA2C;AACzCF,IAAAA,GAAG,CAACC,IAAJ,GAAWF,IAAI,CAACE,IAAhB;AACD,GAFD,MAEO;AACL;AACA;AACAD,IAAAA,GAAG,CAACC,IAAJ,GAAW,IAAX;AACD;;AAED,MAAIF,IAAI,CAACI,KAAL,IAAcJ,IAAI,CAACI,KAAL,CAAWC,MAAX,GAAoB,CAAtC,EAAyC;AACvCJ,IAAAA,GAAG,CAACG,KAAJ,GAAYJ,IAAI,CAACI,KAAL,CACTE,GADS,CACL,UAACC,IAAD;AAAA,aAAW;AACdC,QAAAA,IAAI,EAAED,IAAI,CAACC,IAAL,CAAUC,KADF;AAEdC,QAAAA,IAAI,EAAEH,IAAI,CAACG,IAFG;AAGdC,QAAAA,KAAK,EAAEJ,IAAI,CAACI;AAHE,OAAX;AAAA,KADK,CAAZ;AAMD,GAPD,MAOO;AACLV,IAAAA,GAAG,CAACG,KAAJ,GAAY,IAAZ;AACD;;AAED,SAAOH,GAAP;AACD,CAvBD;AAyBA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMW,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACZ,IAAD,EAAU;AACjC,MAAMa,IAAI,GAAGb,IAAI,CAACE,IAAlB;AACA,MAAMY,KAAK,GAAGd,IAAI,CAACI,KAAL,IAAc,EAA5B;AAEA,MAAMW,UAAU,GAAGpB,KAAK,CAACqB,MAAN,CAAaC,MAAb,CAAoBlB,UAAU,CAAC;AAChDG,IAAAA,IAAI,EAAEW,IAD0C;AAEhDT,IAAAA,KAAK,EAAEU;AAFyC,GAAD,CAA9B,CAAnB;AAKA,SAAOC,UAAP;AACD,CAVD,C,CAYA;;;AACA,IAAMG,oBAAoB,GAAG,SAAvBA,oBAAuB,CAACL,IAAD,EAAsB;AAAA,MAAfC,KAAe,uEAAP,EAAO;AACjD,MAAMd,IAAI,GAAG;AAAEE,IAAAA,IAAI,EAAEW;AAAR,GAAb;AACAb,EAAAA,IAAI,CAACI,KAAL,GAAaU,KAAK,CAACR,GAAN,CAAU,UAACC,IAAD,EAAU;AAC/B,WAAOX,OAAO,CAACuB,SAAR,CAAkBZ,IAAlB,IACHA,IADG,GAEHX,OAAO,CAACwB,IAAR,CAAaC,+BAAb,CAA6Cd,IAA7C,CAFJ;AAGD,GAJY,CAAb;AAKA,SAAOK,gBAAgB,CAACZ,IAAD,CAAvB;AACD,CARD;;AAUAH,OAAO,CAACe,gBAAR,GAA2BA,gBAA3B;AACAf,OAAO,CAACqB,oBAAR,GAA+BA,oBAA/B","sourcesContent":["'use strict'\n\nconst protons = require('protons')\nconst proto = protons(require('./dag.proto.js'))\nconst DAGLink = require('./dag-link/dagLink')\n\nexports = module.exports\n\nconst toProtoBuf = (node) => {\n  const pbn = {}\n\n  if (node.Data && node.Data.byteLength > 0) {\n    pbn.Data = node.Data\n  } else {\n    // NOTE: this has to be null in order to match go-ipfs serialization\n    // `null !== new Uint8Array(0)`\n    pbn.Data = null\n  }\n\n  if (node.Links && node.Links.length > 0) {\n    pbn.Links = node.Links\n      .map((link) => ({\n        Hash: link.Hash.bytes,\n        Name: link.Name,\n        Tsize: link.Tsize\n      }))\n  } else {\n    pbn.Links = null\n  }\n\n  return pbn\n}\n\n/**\n * Serialize internal representation into a binary PB block.\n *\n * @param {Object} node - Internal representation of a PB block\n * @returns {Uint8Array} - The encoded binary representation\n */\nconst serializeDAGNode = (node) => {\n  const data = node.Data\n  const links = node.Links || []\n\n  const serialized = proto.PBNode.encode(toProtoBuf({\n    Data: data,\n    Links: links\n  }))\n\n  return serialized\n}\n\n// Serialize an object where the `Links` might not be a `DAGLink` instance yet\nconst serializeDAGNodeLike = (data, links = []) => {\n  const node = { Data: data }\n  node.Links = links.map((link) => {\n    return DAGLink.isDAGLink(link)\n      ? link\n      : DAGLink.util.createDagLinkFromB58EncodedHash(link)\n  })\n  return serializeDAGNode(node)\n}\n\nexports.serializeDAGNode = serializeDAGNode\nexports.serializeDAGNodeLike = serializeDAGNodeLike\n"]},"metadata":{},"sourceType":"script"}